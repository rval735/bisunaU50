//
//  main.cpp
//  TestOpenCL
//
//  Created by RHVT on 6/5/19.
//  Copyright Â© 2019 R. All rights reserved.
//

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

#define CL_SILENCE_DEPRECATION

#include <time.h>
#include <stdio.h>
#include "NN/NNetwork.hpp"

int main (int argc, const char * argv[])
{
	// std::string argv_str(argv[0]);
	// std::string base = argv_str.substr(0, argv_str.find_last_of("/"));
	// printf("Location: %s\n", base.c_str());

    uintT time0 = static_cast<unsigned int>(time(NULL));

    float result = NNFunction::mainBiSUNA(argv[1]);

    uintT time1 = static_cast<unsigned int>(time(NULL));
    uintT timeDiff = time1 - time0;

    printf("TimeDiff: %i secs\n", timeDiff);
    printf("Last best score: %f\n", result);

    return EXIT_SUCCESS;
}


///**********
//Copyright (c) 2020, Xilinx, Inc.
//All rights reserved.
//
//Redistribution and use in source and binary forms, with or without modification,
//are permitted provided that the following conditions are met:
//
//1. Redistributions of source code must retain the above copyright notice,
//this list of conditions and the following disclaimer.
//
//2. Redistributions in binary form must reproduce the above copyright notice,
//this list of conditions and the following disclaimer in the documentation
//and/or other materials provided with the distribution.
//
//3. Neither the name of the copyright holder nor the names of its contributors
//may be used to endorse or promote products derived from this software
//without specific prior written permission.
//
//THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
//ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
//ARE DISCLAIMED.
//IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//INDIRECT,
//INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//LIMITED TO,
//PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
//BUSINESS INTERRUPTION)
//HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
//LIABILITY,
//OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//THIS SOFTWARE,
//EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//**********/
//#include "xcl2/xcl2.hpp"
//#include <vector>
//
//using std::vector;
//
//static const int DATA_SIZE = 1024;
//static const std::string error_message =
//    "Error: Result mismatch:\n"
//    "i = %d CPU result = %d Device result = %d\n";
//
//// This example illustrates the very simple OpenCL example that performs
//// an addition on two vectors
//int main(int argc, char **argv) {
//
//	return 0;
////  if (argc != 2) {
////    std::cout << "Usage: " << argv[0] << " <XCLBIN File>" << std::endl;
////    return EXIT_FAILURE;
////  }
////
////  std::string binaryFile = argv[1];
////  // compute the size of array in bytes
////  size_t size_in_bytes = DATA_SIZE * sizeof(int);
////  cl_int err;
////  cl::CommandQueue q;
////  cl::Kernel krnl_vector_add;
////  cl::Context context;
////
////  // Creates a vector of DATA_SIZE elements with an initial value of 10 and 32
////  vector<int, aligned_allocator<int>> source_a(DATA_SIZE, 10);
////  vector<int, aligned_allocator<int>> source_b(DATA_SIZE, 32);
////  vector<int, aligned_allocator<int>> source_results(DATA_SIZE);
////
////  // The get_xil_devices will return vector of Xilinx Devices
////  auto devices = xcl::get_xil_devices();
////
////  // read_binary_file() is a utility API which will load the binaryFile
////  // and will return the pointer to file buffer.
////  auto fileBuf = xcl::read_binary_file(binaryFile);
////  cl::Program::Binaries bins{{fileBuf.data(), fileBuf.size()}};
////  int valid_device = 0;
////  for (unsigned int i = 0; i < devices.size(); i++) {
////    auto device = devices[i];
////    // Creating Context and Command Queue for selected Device
////    OCL_CHECK(err, context = cl::Context(device, NULL, NULL, NULL, &err));
////    OCL_CHECK(err, q = cl::CommandQueue(context, device,
////                                        CL_QUEUE_PROFILING_ENABLE, &err));
////
////    std::cout << "Trying to program device[" << i
////              << "]: " << device.getInfo<CL_DEVICE_NAME>() << std::endl;
////    cl::Program program(context, {device}, bins, NULL, &err);
////    if (err != CL_SUCCESS) {
////      std::cout << "Failed to program device[" << i << "] with xclbin file!\n";
////    } else {
////      std::cout << "Device[" << i << "]: program successful!\n";
////      // This call will extract a kernel out of the program we loaded in the
////      // previous line. A kernel is an OpenCL function that is executed on the
////      // FPGA. This function is defined in the src/vetor_addition.cl file.
////      OCL_CHECK(err, krnl_vector_add = cl::Kernel(program, "vector_add", &err));
////      valid_device++;
////      break; // we break because we found a valid device
////    }
////  }
////  if (valid_device == 0) {
////    std::cout << "Failed to program any device found, exit!\n";
////    exit(EXIT_FAILURE);
////  }
////
////  // These commands will allocate memory on the FPGA. The cl::Buffer objects can
////  // be used to reference the memory locations on the device. The cl::Buffer
////  // object cannot be referenced directly and must be passed to other OpenCL
////  // functions.
////  OCL_CHECK(err,
////            cl::Buffer buffer_a(context, CL_MEM_USE_HOST_PTR | CL_MEM_READ_ONLY,
////                                size_in_bytes, source_a.data(), &err));
////  OCL_CHECK(err,
////            cl::Buffer buffer_b(context, CL_MEM_USE_HOST_PTR | CL_MEM_READ_ONLY,
////                                size_in_bytes, source_b.data(), &err));
////  OCL_CHECK(err, cl::Buffer buffer_result(
////                     context, CL_MEM_USE_HOST_PTR | CL_MEM_WRITE_ONLY,
////                     size_in_bytes, source_results.data(), &err));
////
////  // set the kernel Arguments
////  int narg = 0;
////  OCL_CHECK(err, err = krnl_vector_add.setArg(narg++, buffer_result));
////  OCL_CHECK(err, err = krnl_vector_add.setArg(narg++, buffer_a));
////  OCL_CHECK(err, err = krnl_vector_add.setArg(narg++, buffer_b));
////  OCL_CHECK(err, err = krnl_vector_add.setArg(narg++, DATA_SIZE));
////
////  // These commands will load the source_a and source_b vectors from the host
////  // application and into the buffer_a and buffer_b cl::Buffer objects. The data
////  // will be be transferred from system memory over PCIe to the FPGA on-board
////  // DDR memory.
////  OCL_CHECK(err, err = q.enqueueMigrateMemObjects({buffer_a, buffer_b},
////                                                  0 /* 0 means from host*/));
////
////  // Launch the Kernel
////  OCL_CHECK(err, err = q.enqueueTask(krnl_vector_add));
////
////  // The result of the previous kernel execution will need to be retrieved in
////  // order to view the results. This call will write the data from the
////  // buffer_result cl_mem object to the source_results vector
////  OCL_CHECK(err, err = q.enqueueMigrateMemObjects({buffer_result},
////                                                  CL_MIGRATE_MEM_OBJECT_HOST));
////  q.finish();
////
////  int match = 0;
////  printf("Result = \n");
////  for (int i = 0; i < DATA_SIZE; i++) {
////    int host_result = source_a[i] + source_b[i];
////    if (source_results[i] != host_result) {
////      printf(error_message.c_str(), i, host_result, source_results[i]);
////      match = 1;
////      break;
////    } else {
////      printf("%d ", source_results[i]);
////      if (((i + 1) % 16) == 0)
////        printf("\n");
////    }
////  }
////
////  std::cout << "TEST " << (match ? "FAILED" : "PASSED") << std::endl;
////  return (match ? EXIT_FAILURE : EXIT_SUCCESS);
//}
